# ---This alias effectively creates a bookmarking app---
# it adds global symlink shortcuts for use with the 'cds' command
# ex) 'cds studycloud' will run 'cd -P ~/.myaliases/.short/studycloud'
# to add a shortcut: go to the target directory and run 'cds + <shortcut_name>' or 'cds + .' to use the current directory name
# to remove a shortcut: run 'cds - <shortcut_name>' (you can also tack on multiple shortcut names separated by spaces)
# to list your shortcuts: run 'cds .'
cds() {
    # path to the directory in which cds shortcut symlinks are stored
    local SHORT_PATH="$ABSPATH/.short"
    # make sure it exists
    mkdir -p "$SHORT_PATH"
    # determine what the user wants us to do
    # and ensure that the provided command fits the described interface exactly
    # if it doesn't, we fall back on the behavior of regular cd
    if [ $# -eq 1 ] && [ "$1" = "." ]; then
        # display the user's current shortcuts if they type "cds ."
        ls "$SHORT_PATH"
    elif [ $# -eq 2 ] && [ "$1" = "+" ] && [ "$2" != '-' ]; then
        # if the user typed 'cds + <shortcut_name>',
        # create a new cds shortcut or overwrite an existing one
        # note that '-' is an invalid shortcut name
        ln -sfn "$PWD" "$SHORT_PATH/$2"
    elif [ $# -ge 2 ] && [ "$1" = "-" ]; then
        # if the user typed 'cds - <shortcut_names>',
        # remove as many of the provided existing shortcuts as possible
        shift
        ( \cd "$SHORT_PATH" && rm -f "$@" )
    elif [ $# -eq 1 ] && [ -d "$SHORT_PATH/$1" ]; then
        # if the user typed "cds <shortcut_name>" and <shortcut_name>
        # exists, try to use it
        # but first, give priority to any files in the current dir with
        # the same shortcut name
        # and if neither of them work, fall back on the regular behavior of cd
        # so that the user only sees the error message from regular cd
        \cd "$@" 2>/dev/null || \cd -P "$SHORT_PATH/$1" >/dev/null 2>&1 || \cd "$@"
    else
        \cd "$@"
    fi
}

# enable tab completions for cds (only if the shell is bash!)
if [ -n "$BASH_VERSION" ]; then
    # define a custom tab-completion function for cds
    _cds() {
        local SHORT_PATH="$ABSPATH/.short"
        # array variable storing the possible completions
        COMPREPLY=()
        # the current completion word
        local word="${COMP_WORDS[COMP_CWORD]}"
        # tab completion for 'cds + [tab]', 'cds - [tab]', 'cds + <letter(s)>[tab]', or 'cds - <letter(s)>[tab]', 'cds [tab]', or 'cds <letter(s)>[tab]'
        # is simply the list of current shortcuts
        if [ "${COMP_WORDS[1]}" = "-" ] || [ "${COMP_WORDS[1]}" = "+" ] || ( [ "$1" = "$3" ] && [ "${word/'/'}" = "$word" ] ); then
            local temp_reply=( $(compgen -W "$(ls "$SHORT_PATH")" -- "$word") )
            # if there isn't anything (like a - or +) in front of the word we are completing
            if [ "$1" = "$3" ]; then
                _cd
                local d
                for d in "${temp_reply[@]}"; do
                    # append a slash to cds's completions
                    # and then add them to the rest of the completions
                    [ ! -d "$d" ] && COMPREPLY+=( "${d/%//}" )
                done
            else
                COMPREPLY+=( "${temp_reply[@]}" )
            fi
            return
        # tab completion for 'cds /[tab]', 'cds <letter(s)>/[tab]', 'cds <letter(s)>/<letter(s)>/[tab], or some variation with a slash
        # needs to go find subdirectories
        elif [ "$1" = "$3" ]; then
            # get the name of the shortcut (ie the text before the first slash)
            local shortcut="$(cut -d/ -f1 <<< "$word")"
            # resolve the path to the shortcut symlink so that completions
            # like <shortcut>/../ and <shortcut>/./ will work as desired
            local sympath="$(cd -P "$SHORT_PATH/$shortcut" >/dev/null 2>&1 && pwd || echo "$SHORT_PATH/$shortcut")"
            # if the user is using a cds shortcut
            if [ "$shortcut" != "" ] && [ ! -d "$shortcut" ] && [ -d "$sympath" ]; then
                # the absolute path of the text that the user is typing
                totalpath="$sympath/${word#*/}"
                # fake a regular call to _cd. it won't even know the difference ;p
                COMP_LINE="cd -P $totalpath"
                COMP_POINT="${#COMP_LINE}"
                COMP_WORDS[0]="cd"
                COMP_WORDS[1]="-P"
                COMP_WORDS[2]="$totalpath"
                COMP_CWORD=2
                _cd
                # replace all instances of the fullpath name with the shortcut name
                COMPREPLY=( "${COMPREPLY[@]/$sympath/$shortcut}" )
                COMPREPLY=( "${COMPREPLY[@]/%//}" ) # append a slash to every completion
                return
            fi
        fi
        _cd "$@" # otherwise, the user is just typing a regular path
    }

    # command to enable cds tab-completion
    # nospace tells it to not put a space afterward
    type _cd &>/dev/null && complete -o nospace -F _cds cds
fi

