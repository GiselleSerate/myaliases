# Consider using a real Makefile instead of this file. Real Makefiles are actually built for this
# and you can do all of this in a Makefile. 

# Valgrind run on file
val() {
	valgrind --leak-check=full ./"$1"
}

# Valgrind to file
valf() {
	valgrind --leak-check=full ./"$1" 2>| "$1"-val.out
}

# Makes and then valgrinds a file.
mval() {
	make "$1"
	val "$1"
}

# Makes and then valgrinds to a file
mvalf() {
	make "$1"
	valf "$1"
}

# Vanilla; fully compile independent c++ file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension.
#	 don't include the dot in your second argument
clangv() {
	echo clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
	clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
}

# Run; a wrapper for clangv that immediately runs the output file after compilation
# this is useful for quick debugging and editing
# usage: same as clangv
clangr() {
	clangv "$@";
	echo ./"$1${2+.}${2:-}";
	./"$1${2+.}${2:-}";
}


# Partial; partially compile c++ to output file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension
#	 don't include the dot in your second argument
clangp() {
	echo clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
	clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
}


# Link; link c++ file and run the compiled program automatically
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangl() {
	local ARGS=("$@");
	echo clang++ -o "$1" ${ARGS[@]/%/.o};
	clang++ -o "$1" ${ARGS[@]/%/.o}; 
	echo ./"$1";
	./"$1";
}

# Total; a wrapper for clangl and clangp.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangt() {
	for arg; do
		clangp "$arg";
	done
	clangl "$@";
}

# Delete; a wrapper for clangt that cleans up once the program has been run.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program. Deletes all .o and executables.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangd() {
	local ARGS=("$@");
	clangt "$@";
	echo Deleting all object and executable files: ${ARGS[@]/%/.o} "$1";
	rm ${ARGS[@]/%/.o} "$1";
}
# alias to run sublime text from anywhere
alias subl='"/mnt/c/Program Files/Sublime Text 3/sublime_text.exe"'

if [ -d '/mnt/c/Windows' ]; then

    # alias cmd for calling the windows command line from bash
    alias cmd='/mnt/c/Windows/System32/cmd.exe /C'

    # wanna go to desktop
    alias desk='cd /mnt/c/Users/$(cmd "echo | set /p=%USERNAME%")/Desktop'

    # open windows file manager in the current directory
    alias explorer='/mnt/c/Windows/explorer.exe .'

fi

# source bash
alias srcbash='source ~/.bashrc'

# ---This alias effectively creates a bookmarking app---
# it adds global symlink shortcuts for use with the 'cds' command
# ex: 'cds studycloud' will run 'cd -P ~/.short/studycloud'
# to add a shortcut: go to the target directory and run 'cds + <shortcut_name>' or 'cds + .' to use the current directory name
# to remove a shortcut: run 'cds - <shortcut_name>' (you can also tack on multiple shortcut names separated by spaces)
# to list your shortcuts: run 'cds .'
cds() {
    if [ ! -d ~/.short ]; then
        mkdir ~/.short
    fi
    if [ $# -eq 1 ] && [ "$1" = "." ]; then
        ls ~/.short/
    elif [ $# -eq 2 ] && [ "$1" = "+" ]; then
        if [ "$2" != "-" ]; then
            ln -sfn "$PWD" "$HOME/.short/$2"
        fi
    elif [ $# -ge 2 ] && [ "$1" = "-" ]; then
        local args=( ${@:2} )
        eval "rm ${args[@]/#/"~/.short/"}"
    elif [ $# -eq 0 ] || [ -d "$1" ] || [ "$1" = "-" ]; then
        cd "$@"
    elif [ -d "$(realpath ~/.short/$1)" ]; then
        cd -P ~/.short/$1
    else
        echo "cd: $1: No such file or directory"
    fi
}
alias serve='php artisan serve &>/dev/null &'

# Run background serve commands without taking up a terminal window. 
bgsrv() {
	# Start web server.
	php artisan serve &>/dev/null &
	# Start watching sass files for changes.
	npm run watch &>/dev/null &
}
# Consider using a real Makefile instead of this file. Real Makefiles are actually built for this
# and you can do all of this in a Makefile. 

# Valgrind run on file
val() {
	valgrind --leak-check=full ./"$1"
}

# Valgrind to file
valf() {
	valgrind --leak-check=full ./"$1" 2>| "$1"-val.out
}

# Makes and then valgrinds a file.
mval() {
	make "$1"
	val "$1"
}

# Makes and then valgrinds to a file
mvalf() {
	make "$1"
	valf "$1"
}

# Vanilla; fully compile independent c++ file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension.
#	 don't include the dot in your second argument
clangv() {
	echo clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
	clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
}

# Run; a wrapper for clangv that immediately runs the output file after compilation
# this is useful for quick debugging and editing
# usage: same as clangv
clangr() {
	clangv "$@";
	echo ./"$1${2+.}${2:-}";
	./"$1${2+.}${2:-}";
}


# Partial; partially compile c++ to output file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension
#	 don't include the dot in your second argument
clangp() {
	echo clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
	clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
}


# Link; link c++ file and run the compiled program automatically
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangl() {
	local ARGS=("$@");
	echo clang++ -o "$1" ${ARGS[@]/%/.o};
	clang++ -o "$1" ${ARGS[@]/%/.o}; 
	echo ./"$1";
	./"$1";
}

# Total; a wrapper for clangl and clangp.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangt() {
	for arg; do
		clangp "$arg";
	done
	clangl "$@";
}

# Delete; a wrapper for clangt that cleans up once the program has been run.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program. Deletes all .o and executables.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangd() {
	local ARGS=("$@");
	clangt "$@";
	echo Deleting all object and executable files: ${ARGS[@]/%/.o} "$1";
	rm ${ARGS[@]/%/.o} "$1";
}
# alias to run sublime text from anywhere
alias subl='"/mnt/c/Program Files/Sublime Text 3/sublime_text.exe"'

if [ -d '/mnt/c/Windows' ]; then

    # alias cmd for calling the windows command line from bash
    alias cmd='/mnt/c/Windows/System32/cmd.exe /C'

    # wanna go to desktop
    alias desk='cd /mnt/c/Users/$(cmd "echo | set /p=%USERNAME%")/Desktop'

    # open windows file manager in the current directory
    alias explorer='/mnt/c/Windows/explorer.exe .'

fi

# source bash
alias srcbash='source ~/.bashrc'

# ---This alias effectively creates a bookmarking app---
# it adds global symlink shortcuts for use with the 'cds' command
# ex: 'cds studycloud' will run 'cd -P ~/.short/studycloud'
# to add a shortcut: go to the target directory and run 'cds + <shortcut_name>' or 'cds + .' to use the current directory name
# to remove a shortcut: run 'cds - <shortcut_name>' (you can also tack on multiple shortcut names separated by spaces)
# to list your shortcuts: run 'cds .'
cds() {
    if [ ! -d ~/.short ]; then
        mkdir ~/.short
    fi
    if [ $# -eq 1 ] && [ "$1" = "." ]; then
        ls ~/.short/
    elif [ $# -eq 2 ] && [ "$1" = "+" ]; then
        if [ "$2" != "-" ]; then
            ln -sfn "$PWD" "$HOME/.short/$2"
        fi
    elif [ $# -ge 2 ] && [ "$1" = "-" ]; then
        local args=( ${@:2} )
        eval "rm ${args[@]/#/"~/.short/"}"
    elif [ $# -eq 0 ] || [ -d "$1" ] || [ "$1" = "-" ]; then
        cd "$@"
    elif [ -d "$(realpath ~/.short/$1)" ]; then
        cd -P ~/.short/$1
    else
        echo "cd: $1: No such file or directory"
    fi
}
alias serve='php artisan serve &>/dev/null &'

# Run background serve commands without taking up a terminal window. 
bgsrv() {
	# Start web server.
	php artisan serve &>/dev/null &
	# Start watching sass files for changes.
	npm run watch &>/dev/null &
}
# Consider using a real Makefile instead of this file. Real Makefiles are actually built for this
# and you can do all of this in a Makefile. 

# Valgrind run on file
val() {
	valgrind --leak-check=full ./"$1"
}

# Valgrind to file
valf() {
	valgrind --leak-check=full ./"$1" 2>| "$1"-val.out
}

# Makes and then valgrinds a file.
mval() {
	make "$1"
	val "$1"
}

# Makes and then valgrinds to a file
mvalf() {
	make "$1"
	valf "$1"
}

# Vanilla; fully compile independent c++ file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension.
#	 don't include the dot in your second argument
clangv() {
	echo clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
	clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
}

# Run; a wrapper for clangv that immediately runs the output file after compilation
# this is useful for quick debugging and editing
# usage: same as clangv
clangr() {
	clangv "$@";
	echo ./"$1${2+.}${2:-}";
	./"$1${2+.}${2:-}";
}


# Partial; partially compile c++ to output file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension
#	 don't include the dot in your second argument
clangp() {
	echo clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
	clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
}


# Link; link c++ file and run the compiled program automatically
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangl() {
	local ARGS=("$@");
	echo clang++ -o "$1" ${ARGS[@]/%/.o};
	clang++ -o "$1" ${ARGS[@]/%/.o}; 
	echo ./"$1";
	./"$1";
}

# Total; a wrapper for clangl and clangp.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangt() {
	for arg; do
		clangp "$arg";
	done
	clangl "$@";
}

# Delete; a wrapper for clangt that cleans up once the program has been run.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program. Deletes all .o and executables.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangd() {
	local ARGS=("$@");
	clangt "$@";
	echo Deleting all object and executable files: ${ARGS[@]/%/.o} "$1";
	rm ${ARGS[@]/%/.o} "$1";
}
# alias to run sublime text from anywhere
alias subl='"/mnt/c/Program Files/Sublime Text 3/sublime_text.exe"'

if [ -d '/mnt/c/Windows' ]; then

    # alias cmd for calling the windows command line from bash
    alias cmd='/mnt/c/Windows/System32/cmd.exe /C'

    # wanna go to desktop
    alias desk='cd /mnt/c/Users/$(cmd "echo | set /p=%USERNAME%")/Desktop'

    # open windows file manager in the current directory
    alias explorer='/mnt/c/Windows/explorer.exe .'

fi

# source bash
alias srcbash='source ~/.bashrc'

# ---This alias effectively creates a bookmarking app---
# it adds global symlink shortcuts for use with the 'cds' command
# ex: 'cds studycloud' will run 'cd -P ~/.short/studycloud'
# to add a shortcut: go to the target directory and run 'cds + <shortcut_name>' or 'cds + .' to use the current directory name
# to remove a shortcut: run 'cds - <shortcut_name>' (you can also tack on multiple shortcut names separated by spaces)
# to list your shortcuts: run 'cds .'
cds() {
    if [ ! -d ~/.short ]; then
        mkdir ~/.short
    fi
    if [ $# -eq 1 ] && [ "$1" = "." ]; then
        ls ~/.short/
    elif [ $# -eq 2 ] && [ "$1" = "+" ]; then
        if [ "$2" != "-" ]; then
            ln -sfn "$PWD" "$HOME/.short/$2"
        fi
    elif [ $# -ge 2 ] && [ "$1" = "-" ]; then
        local args=( ${@:2} )
        eval "rm ${args[@]/#/"~/.short/"}"
    elif [ $# -eq 0 ] || [ -d "$1" ] || [ "$1" = "-" ]; then
        cd "$@"
    elif [ -d "$(realpath ~/.short/$1)" ]; then
        cd -P ~/.short/$1
    else
        echo "cd: $1: No such file or directory"
    fi
}
alias serve='php artisan serve &>/dev/null &'

# Run background serve commands without taking up a terminal window. 
bgsrv() {
	# Start web server.
	php artisan serve &>/dev/null &
	# Start watching sass files for changes.
	npm run watch &>/dev/null &
}
# Consider using a real Makefile instead of this file. Real Makefiles are actually built for this
# and you can do all of this in a Makefile. 

# Valgrind run on file
val() {
	valgrind --leak-check=full ./"$1"
}

# Valgrind to file
valf() {
	valgrind --leak-check=full ./"$1" 2>| "$1"-val.out
}

# Makes and then valgrinds a file.
mval() {
	make "$1"
	val "$1"
}

# Makes and then valgrinds to a file
mvalf() {
	make "$1"
	valf "$1"
}

# Vanilla; fully compile independent c++ file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension.
#	 don't include the dot in your second argument
clangv() {
	echo clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
	clang++ -std=c++11 -pedantic -Wall -Wextra "$1".cpp -o "$1${2+.}${2:-}";
}

# Run; a wrapper for clangv that immediately runs the output file after compilation
# this is useful for quick debugging and editing
# usage: same as clangv
clangr() {
	clangv "$@";
	echo ./"$1${2+.}${2:-}";
	./"$1${2+.}${2:-}";
}


# Partial; partially compile c++ to output file
# usage: pass one argument that does not contain the file extension.
#	 an optional second argument specifies the file extension
#	 don't include the dot in your second argument
clangp() {
	echo clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
	clang++ -c -o "$1.${2:-o}" -std=c++11 -pedantic -Wall -Wextra "$1".cpp;
}


# Link; link c++ file and run the compiled program automatically
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangl() {
	local ARGS=("$@");
	echo clang++ -o "$1" ${ARGS[@]/%/.o};
	clang++ -o "$1" ${ARGS[@]/%/.o}; 
	echo ./"$1";
	./"$1";
}

# Total; a wrapper for clangl and clangp.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangt() {
	for arg; do
		clangp "$arg";
	done
	clangl "$@";
}

# Delete; a wrapper for clangt that cleans up once the program has been run.
# Partial compiles all inputs to .o output files, links these outputs, 
# and then runs the final program. Deletes all .o and executables.
# usage: pass one argument to link into and any other sources
#	 that you're inserting as subsequent arguments in the
#	 order of most dependent to least dependent.
#	 leave off any file extensions
clangd() {
	local ARGS=("$@");
	clangt "$@";
	echo Deleting all object and executable files: ${ARGS[@]/%/.o} "$1";
	rm ${ARGS[@]/%/.o} "$1";
}
# alias to run sublime text from anywhere
alias subl='"/mnt/c/Program Files/Sublime Text 3/sublime_text.exe"'

if [ -d '/mnt/c/Windows' ]; then

    # alias cmd for calling the windows command line from bash
    alias cmd='/mnt/c/Windows/System32/cmd.exe /C'

    # wanna go to desktop
    alias desk='cd /mnt/c/Users/$(cmd "echo | set /p=%USERNAME%")/Desktop'

    # open windows file manager in the current directory
    alias explorer='/mnt/c/Windows/explorer.exe .'

fi

# source bash
alias srcbash='source ~/.bashrc'

# ---This alias effectively creates a bookmarking app---
# it adds global symlink shortcuts for use with the 'cds' command
# ex: 'cds studycloud' will run 'cd -P ~/.short/studycloud'
# to add a shortcut: go to the target directory and run 'cds + <shortcut_name>' or 'cds + .' to use the current directory name
# to remove a shortcut: run 'cds - <shortcut_name>' (you can also tack on multiple shortcut names separated by spaces)
# to list your shortcuts: run 'cds .'
cds() {
    if [ ! -d ~/.short ]; then
        mkdir ~/.short
    fi
    if [ $# -eq 1 ] && [ "$1" = "." ]; then
        ls ~/.short/
    elif [ $# -eq 2 ] && [ "$1" = "+" ]; then
        if [ "$2" != "-" ]; then
            ln -sfn "$PWD" "$HOME/.short/$2"
        fi
    elif [ $# -ge 2 ] && [ "$1" = "-" ]; then
        local args=( ${@:2} )
        eval "rm ${args[@]/#/"~/.short/"}"
    elif [ $# -eq 0 ] || [ -d "$1" ] || [ "$1" = "-" ]; then
        cd "$@"
    elif [ -d "$(realpath ~/.short/$1)" ]; then
        cd -P ~/.short/$1
    else
        echo "cd: $1: No such file or directory"
    fi
}
alias serve='php artisan serve &>/dev/null &'

# Run background serve commands without taking up a terminal window. 
bgsrv() {
	# Start web server.
	php artisan serve &>/dev/null &
	# Start watching sass files for changes.
	npm run watch &>/dev/null &
}
